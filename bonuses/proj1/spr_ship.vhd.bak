-- sprite: colorful hardware sprite
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

-- Common constants
use work.defender_common.all;

entity spr_ship is
    generic (
        g_width : integer := 15;        -- graphic width in pixels
        g_height : integer := 6;        -- graphic height in pixels
        g_scale_x : integer := 1;       -- sprite width scale-factor
        g_scale_y : integer := 1;       -- sprite height scale-factor
    );
    port (
        i_clock : in std_logic;                      -- clock
        i_reset: in std_logic;                      -- synchronous reset
        i_pos: in t_point_2d; -- top left of sprite
        i_scan_pos: in t_point_2d_onscreen; -- current VGA scan position
        i_draw_en: in std_logic;


        o_color : out integer range 0 to c_max_color;      -- pixel colour to draw
        o_draw : out std_logic                  -- sprite is drawing

    );
end entity spr_ship;

architecture rtl of spr_ship is

    -- Constants
    constant c_transparent : integer := 1;
    constant c_palette_size : integer := 16;

    -- Types
    type t_state is (ST_IDLE, ST_START, ST_AWAIT_POS, ST_DRAW, ST_NEXT_LINE, ST_DONE);

    -- Signals
    signal r_state : t_state := ST_IDLE;
    signal r_next_state : t_state;
    signal r_last_pixel : boolean;
    signal r_last_line : boolean;

    signal r_clut_addr : std_logic_vector(3 downto 0);
    signal r_clut_out : std_logic_vector(11 downto 0);
    signal r_spr_rom_addr : std_logic_vector(2 downto 0);
    signal r_spr_rom_out : std_logic_vector(59 downto 0);

    -- Scale counters
    signal r_scale_cnt_x : integer range 0 to g_scale_x-1 := 0;
    signal r_scale_cnt_y : integer range 0 to g_scale_y-1 := 0;

    -- Position within sprite
    signal r_spr_pos_x : integer range 0 to g_width-1 := 0;
    signal r_spr_pos_y : integer range 0 to g_height-1 := 0;

    
begin

    -- State machine
    process(i_clock)
    begin
        if rising_edge(i_clock) then
            r_state <= r_next_state;

            case r_state is
                when ST_START =>
                    r_spr_pos_y <= 0;
                    r_scale_cnt_y <= 0;
                
                when ST_AWAIT_POS => 
                    r_spr_pos_x <= 0;
                    r_scale_cnt_x <= 0;

                when ST_DRAW => 
                    if (g_scale_x <= 1 or r_scale_cnt_x = g_scale_x-1) then
                        r_spr_pos_x <= r_spr_pos_x + 1;
                        r_scale_cnt_x <= 0;
                    else
                        r_scale_cnt_x <= r_scale_cnt_x + 1;
                    end if;

                when ST_NEXT_LINE =>
                    if (g_scale_y <= 1 or r_scale_cnt_y = g_scale_y-1) then
                        r_spr_pos_y <= r_spr_pos_y + 1;
                        r_scale_cnt_y <= 0;
                    else
                        r_scale_cnt_y <= r_scale_cnt_y + 1;
                    end if;

            end case;

            if i_reset = '1' then
                r_state <= ST_IDLE;
            end if;

        end if;
    end process;

    -- Status signals
    r_last_pixel <= '1' when (r_spr_pos_x = g_width-1  and r_scale_cnt_x = g_scale_x-1) else '0';
    r_last_line <= '1' when  (r_spr_pos_y = g_height-1 and r_scale_cnt_y = g_scale_y-1) else '0';
    
    -- Next state logic
    process(r_state)
    begin
        case r_state is
            when ST_IDLE =>
                if (i_scan_pos.x = i_pos.x-2 and i_scan_pos.y = i_pos.y) then
                    r_next_state <= ST_START;
                else
                    r_next_state <= ST_IDLE;
                end if;

            when ST_START => r_next_state <= ST_AWAIT_POS;

            when ST_AWAIT_POS =>
                if (i_scan_pos.x = i_pos.x-2) then
                    r_next_state <= ST_DRAW;
                else
                    r_next_state <= ST_AWAIT_POS;
                end if;

            when ST_DRAW =>
                if (!r_last_pixel) then
                    r_next_state <= ST_DRAW;
                elsif (!r_last_line) then
                    r_next_state <= ST_NEXT_LINE;
                else
                    r_next_state <= ST_DONE;
                end if;

            when ST_NEXT_LINE => r_next_state <= ST_AWAIT_POS;
            when ST_DONE => r_next_state <= ST_IDLE;
            when others => r_next_state <= ST_IDLE;
        
        end case;
    end process;

    -- Outputs
    process(r_state, r_spr_rom_out)
    begin
        if (r_state = ST_DRAW and r_spr_rom_out /= X"1") then -- Are we drawing a non-transparent color?
            o_draw <= '1';
        else
            o_draw <= '0';
        end if;
    end process;
    r_spr_rom_addr <= std_logic_vector(unsigned(r_spr_pos_y, r_spr_rom_addr'LENGTH));
    o_color <= to_integer(unsigned(r_clut_out));

    -- clut address
    process(r_spr_pos_x)
    begin
        -- Pick out 4 bits corresponding to current x value
        r_clut_addr <= r_spr_rom_out((g_width-r_spr_pos_x)*4 - 1 downto (g_width-r_spr_pos_x-1)*4);
    end process;
    
    -- Instantiation
    clut: entity work.async_rom_init generic map(
        numElements => c_palette_size,
        dataWidth => 12,
        initFile => "../res/palette.mif"
    )
    port map(
        addrA => r_clut_addr,
        dataOutA => r_clut_out
    );

    spr_mem: entity work.synch_ram_init generic map(
        numElements => 6,
        dataWidth => 15*4,
        initFile => "../res/spr_ship.mif"
    )
    port map(
        clkA => i_clock,
        writeEnableA => '0',
        addrA => r_spr_rom_addr,
        dataOutA => r_spr_rom_out,
        dataInA => (others => '0')
    );

end architecture rtl;