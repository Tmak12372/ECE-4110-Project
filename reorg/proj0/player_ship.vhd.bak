-- player_ship: Logic and graphics generation
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity player_ship is
    generic (
        g_screen_width : integer := 640;
        g_screen_height : integer := 480;
        g_ship_color : integer := 16#F00#;

        -- Bounding box
        g_bb_width : integer := 30;
        g_bb_height : integer := 20


    );
    port (
        i_clock : in std_logic;
        i_update_pulse : in std_logic;

        -- HMI Inputs
        accel_x_dir, accel_y_dir     : IN STD_LOGIC;
        accel_scale_x, accel_scale_y : IN STD_LOGIC_VECTOR(3 DOWNTO 0);

        i_row : in integer;
        i_column : in integer;

        o_color : out integer range 0 to 4095;
        o_draw : out std_logic
    );
end entity player_ship;

 
architecture rtl of player_ship is
    -- Types

    -- Signals


    -- coords of top left of object
    signal r_xPos : integer range 0 to g_screen_width-1 := g_screen_width/4;
    signal r_yPos : integer range 0 to g_screen_height-1 := g_screen_height/4;

    -- Pixels per frame?
    signal r_xSpeed : integer := 0;
    signal r_ySpeed : integer := 0;
    
begin
    
    -- Set draw output
    process(i_row, i_column, r_xPos, r_yPos)
    begin

        -- is current pixel coordinate inside our box?
        if (i_column >= r_xPos and i_column <= r_xPos+g_bb_width and
            i_row >= r_yPos and i_row <= r_yPos+g_bb_height) then
            
            o_draw <= '1';
            o_color <= g_ship_color;
        else
            o_draw <= '0';
            o_color <= 0;
        end if;
    end process;

    process(i_clock)
        -- Vars
        variable r_xPos_new : integer;
        variable r_yPos_new : integer;
    begin
        if (rising_edge(clk)) then
            if (i_update_pulse) then

                r_xPos_new := r_xPos + r_xSpeed;
                r_yPos_new := r_yPos + r_ySpeed;

                -- Check bounds and clip
                if (r_xPos_new + g_bb_width > g_screen_width/2) then
                    r_xPos_new := g_screen_width/2;
                end if;
                if (r_xPos_new < 0) then
                    r_xPos_new := 0;
                end if;

                if (r_yPos_new + g_bb_height > g_screen_height-1) then
                    r_yPos_new := g_screen_height-1;
                end if;
                if (r_yPos_new < 0) then
                    r_yPos_new := 0;
                end if;

                -- Assign new values
                r_xPos <= r_xPos_new;
                r_yPos <= r_yPos_new;

            end if;
        end if;
    end process;

    -- Set ship speed from user input
    process(accel_x_dir, accel_y_dir, accel_scale_x, accel_scale_y)
        -- Vars
        variable r_xSpeed_new : integer;
        variable r_ySpeed_new : integer;
    begin
        case accel_scale_x is
            when 0 | 1 => r_xSpeed_new := 0;

            when 2 | 3 => r_xSpeed_new := 1;

            when 4 | 5 | 6 | 7  => r_xSpeed_new := 2;
            
            when others => r_xSpeed_new := 0;
        end case;
        case accel_scale_y is
            when 0 | 1 => r_ySpeed_new := 0;

            when 2 | 3 => r_ySpeed_new := 1;

            when 4 | 5 | 6 | 7 => r_ySpeed_new := 2;
            
            when others => r_ySpeed_new := 0;
        end case;

        -- Direction of tilt
        -- x_dir = '0' : left,    x_dir = '1' : right
        -- y_dir = '0' : forward, y_dir = '1' : backward
        if (accel_x_dir = '0') then
            r_xSpeed_new := -r_xSpeed_new;
        end if;
        if (accel_y_dir = '1') then
            r_ySpeed_new := -r_ySpeed_new;
        end if;

        -- Assign new values
        r_xSpeed <= r_xSpeed_new;
        r_ySpeed <= r_ySpeed_new;
    end process;
    
end architecture rtl;